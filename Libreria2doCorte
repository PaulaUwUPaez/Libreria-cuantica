#Paula Natalia Paez Vega
#Escuela Colombiana de ingeniería Julio Garavito
import math


def transpuesta(n):
    k = []
    for i in range(len(n[0])):
        k.append([])
        for j in range(len(n)):
            k[i].append(n[j][i])
    return k
def suma(a,b):
    #Esta función, suma vectores
    d = a[0]+b[0]
    c = a[1]+b[1]
    suma = d,c
    return suma
def multiplicacion(a,b):
    # Esta función, multiplica vectores
    d = round(a[0]*b[0]-a[1]*b[1])
    c = round(a[1]*b[0]+b[1]*a[0])
    producto = d,c
    return producto
def resta(a,b):
    # Esta función, resta vectores
    d = a[0] - b[0]
    c = a[1] - b[1]
    diferencia = d,c
    return diferencia ##(1,2)(1,2)
def division(a,b):
    # Esta función, divide vectores
    c = (((a[0]*a[1]) + (b[0]*b[1])) / (((a[1])**2) + ((b[1])**2)))
    d = (((a[1]*b[0]) - (a[0]*b[1])) / (((a[1])**2) + ((b[1])**2)))
    return round(c), round(d)
def modulo(a):
    # Esta función, saca el modulo del vector sumando ambos elementos y elevandolos al cuadrado, esto dentro del radical
    c = +((((a[0])**2)+((a[1])**2))**(1/2))
    return round(c,2)
def conjugado(a):
    # Esta función, cambia de signo el segundo elemento
    return a[0],(-a[1])
def polarcartesiano(a):
    # Esta funcion cambia de polar a cartesiano
    d = math.radians(float(a[1]))
    c = a[0] * math.cos(d)
    b = a[0] * math.sin(d)
    cartesian = (c, b)
    return cartesian
def fase(a):
    # Esta función, saca la fase del vector
    c = math.atan(a[1]/(a(0)))
    p = c * (180 / math.pi)
    return round(p)
def cartesiano_polar(a):
    #Esta funcion cambia de cartesiano a polar
    c = round((a[0]*math.cos(a[1])))
    d = round((a[0]*math.sin(a[1])))
    return c,d

def AdicionVectoresComplejos(a, b):
    #Función que retorna la adicion de vectores.
    r = [(0, 0)] * len(a)
    for k in range(len(a)):
        r[k] = suma(a[k], b[k])
    return r
def SustracVectoresComplejos(a, b):
    #Función que retorna la sustracción de vectores.
    r = [(0, 0)] * len(a)
    for k in range(len(a)):
        r[k] = resta(a[k], b[k])
    return r
def invvector(a):
    #Función que retorna el inverso aditivo.
    r = [(0, 0)] * len(a)
    for k in range(len(a)):
        r[k] = multiplicacion((-1, 0), v[k])
    return r
def MultEscalarVector(a, b):
    #Función que retorna la multiplicación de un escalar por un vector
    r = [(0, 0)] * len(b)
    for k in range(len(b)):
        r[k] = multiplicacion(a, b[k])
    return r
def AdicionMatriz(a, b):
    #Función que retorna la adición de matrices.
    fila = [(0, 0)] * len(a[0])
    r = [fila] * len(a)
    for j in range(len(a)):
        fila = [(0, 0)] * len(a[0])
        r[j] = fila
        for k in range(len(a[0])):
            r[j][k] = suma(a[j][k], b[j][k])
    return r
def SustracMatriz(a, b):
    #Función que retorna la sustracción de vectores
    fila = [(0, 0)] * len(a[0])
    r = [fila] * len(a)
    for j in range(len(a)):
        fila = [(0, 0)] * len(a[0])
        r[j] = fila
        for k in range(len(a[0])):
            r[j][k] = resta(a[j][k], b[j][k])
    return r
def InversaAditivaMatriz(a):
    #Función que retorna el inverso aditivo de una matriz
    fila = [(0, 0)] * len(a[0])
    r = [fila] * len(a)
    for j in range(len(a)):
        fila = [(0, 0)] * len(a[0])
        r[j] = fila
        for k in range(len(a[0])):
            r[j][k] = multiplicacion((-1, 0), a[j][k])
    return r
def MultEscalarMatriz(a, b):
    #Función que retorna la multiplicación de un escalar por una matriz"
    fila = [(0, 0)] * len(b[0])
    r = [fila] * len(b)
    for j in range(len(b)):
        fila = [(0, 0)] * len(b[0])
        r[j] = fila
        for k in range(len(A[0])):
            r[j][k] = multiplicacion(a, b[j][k])
    return r
def Transpuesta(a):
    #Función que retorna la transpuesta de un vector o matriz
    t = []
    for k in range(len(a[0])):
        t.append([])
        for j in range(len(a)):
            t[k].append(a[j][k])
    return t
def ConjugadaMatVec(a):
    #Función que retorna el conjugado de un vector o matriz
    fila = [(0, 0)] * len(a[0])
    r = [fila] * len(a)
    for j in range(len(a)):
        fila = [(0, 0)] * len(a[0])
        r[j] = fila
        for k in range(len(a[0])):
            r[j][k] = conjugado(a[j][k])
    return r
def AdjuntaMatVec(a):
    #Función que retorna la adjunta de un vector o matriz.
    return Transpuesta(ConjugadaMatVec(a))
def ProductMatrix(a, b):
    #Función que retorna la multiplicación de dos matrices.
    c = []
    for i in range(len(a)):
        c.append([])
        for j in range(len(b[0])):
            c[i].append((0, 0))
            for k in range(len(a[0])):
                c[i][j] = suma(c[i][j],  multiplicacion(a[i][k], b[k][j]))
    return c
def AccionMatVec(a, b):
    #Función que retorna la acción de una matriz sobre un vector.
    return ProductMatrix(a, b)
def ProductoInterno(a, b):
    #Función que retorna el producto interno de dos vectores.
    return ProductMatrix(AdjuntaMatVec(a), b)[0][0]
def cartesiantopolar(a):
    #Función que convierte de cartesiana a polar
    p = math.sqrt((a[0] * 2) + a[1] * 2)
    tet = fase(a)
    return (p, tet)
def Norma(a):
    #Función que retorna la norma de un vector
    if ProductoInterno(a, a)[1] == 0:
        return math.sqrt(ProductoInterno(a, a)[0])
    else:
        b = cartesiantopolar(ProductoInterno(a, a))
        return (math.sqrt(b[0]), 0.5 * b[1])
def DistanciaVec(c, d):
    #Función que retorna la distancia entre dos vectores.
    if ProductoInterno(SustracMatriz(c, d), SustracMatriz(c, d))[1] == 0:
        return math.sqrt(ProductoInterno(SustracMatriz(c, d), SustracMatriz(c, d))[0])
    else:
        a = cartesiantopolar(ProductoInterno(
            SustracMatriz(c, d), SustracMatriz(c, d)))
        return (math.sqrt(a[0]), 0.5 * a[1])
def Unitaria(a):
    #Función que retorna si una matriz es unitaria
    m = ProductMatrix(AdjuntaMatVec(a), a)
    for i in range(len(m)):
        for j in range(len(m[0])):
            if i == j:
                if m[i][j] != (1, 0):
                    if (round(m[i][j][0], 10), round(m[i][j][1], 10)) != (1, 0):
                        return "No unitaria"
            else:
                if m[i][j] != (0, 0):

                    return "No unitaria"
                else:
                    return "Unitaria"
def Hermitiana(a):
    #Función que retorna si una matriz es hermitiana.
    Adjunta = AdjuntaMatVec(a)
    if Adjunta == a:
        return "Hermitiana"
    else:
        return "No es hermitiana"
def ProductTensor(a, b):
    #Función que retorna el producto tensor entre vectores.
    na = len(a)
    nb = len(b)
    nr = nb * na
    r = [(0, 0)] * nr
    index = 0
    for j in range(na):
        for k in range(nb):
            r[index] = multiplicacion(a[j], b[k])
            index += 1
    return r
def TensorMat(a, b):
    #Función que retorna el producto tensor entre matrices
    m = len(a)
    n = len(b)
    size = (len(a) * len(b), len(a[0]) * len(b[0]))
    result = [[(0, 0) for i in range(size[1])] for j in range(size[0])]
    for j in range(size[0]):
        for k in range(size[1]):
            result[j][k] = multiplicacion(a[j // n][k // m], b[j % n][k % m])
    return result
def Module(a):
    #Función que retorna el módulo al cuadrado de un Vector
    b = len(a)
    c = 0.0
    for j in range(b):
        c += squaremodule(a[j][0])
    return c
def ModuleVec(a):
    #Función que retorna el módulo de un Vector
    return math.sqrt(Module(a))
def squaremodule(c):
    #Función que retorna el módulo al cuadrado de un valor complejo
    return (c[0] * 2) + (c[1] * 2)
def normalizar(a):
    #Función que normaliza un vector
    escalar = 1 / math.sqrt(Module(a))
    return MultEscalarMatriz((escalar, 0), a)
def identidad(mat):
    result = [[(0, 0) for i in range(len(mat[0]))] for j in range(len(mat))]
    for i in range(len(mat)):
        for j in range(len(mat[0])):
            if i == j:
                result[i][j] = (1, 0)
    return result
def main():
    print(suma((3.5,7),(4.2,9)))
    print(multiplicacion((3.5,7),(4.2,9)))
    print(division((-2,1),(1,2)))
    print(resta((3.5,7),(4.2,9)))
    print(modulo((1,-1)))
    print(conjugado((6,5)))
    print(fase((1,1)))
    print(cartesiano_polar((1.41,45)))
    print(polarcartesiano((2,math.pi)))
    
main()
